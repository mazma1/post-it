import React from 'react';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import PropTypes from 'prop-types';
import isEmpty from 'lodash/isEmpty';
import MessageBody from '../message-board/MessageBody.jsx';
import MessageItem from '../message-board/MessageItem.jsx';
import MessageForm from './MsgForm.jsx';
import {
  updateReadStatus,
  getGroupMessages } from '../../actions/groupMessages';

/** MessageCard component for message board */
class MessageCard extends React.Component {
  /**
   * Constructor
   * @param {object} props
   */
  constructor(props) {
    super(props);

    this.state = {
      isOpen: false,
      messageId: '',
      clickedMessageId: '',
      messageOpen: false
    };

    // this.setMessageId = this.setMessageId.bind(this);
    this.openModal = this.openModal.bind(this);
    this.closeModal = this.closeModal.bind(this);
    this.onMessageClick = this.onMessageClick.bind(this);
    this.closeMessageBody = this.closeMessageBody.bind(this);
  }

  /**
   * Handles Open Modal event
   * Updates isOpen state
   * @param {SyntheticEvent} event
   * @returns {void} null
   */
  openModal(event) {
    event.stopPropagation();
    this.setState({
      isOpen: true
    });
  }

  /**
   * Handles Close Modal event
   * Updates isOpen state
   * @param {SyntheticEvent} event
   * @returns {void}
   */
  closeModal(event) {
    event.preventDefault();
    this.setState({
      isOpen: false
    });
  }

  /**
   * Closes the message body when the close button is clicked
   * It also dispatches getGroupMessages to get updated list of users that
   * have viewed a message
   * @param {integer} groupId active group id
   * @returns {void}
   */
  closeMessageBody(groupId) {
    this.props.getGroupMessages(groupId);
    this.setState({ messageOpen: false });
  }

   /**
   * Updates the read status of a message when clicked
   * @param {object} clickedMsgProps id and read_status of
   clicked message
   * @returns {func} request to update read status
   */
  onMessageClick(clickedMsgProps) {
    const clickedMessageId = clickedMsgProps.id;
    console.log(clickedMessageId)
    this.setState({
      clickedMessageId,
      messageOpen: true
    });
    const messageDetails = {
      messageId: clickedMessageId,
      username: this.props.authenticatedUsername,
      readBy: clickedMsgProps.read_by,
      groupId: this.props.userGroups.groups[0].id
    };
    return this.props.updateReadStatus(messageDetails);
  }

  /**
   * Render
   * @returns {ReactElement} MessageCard markup
   */
  render() {
    const { hasGroup } = this.props.userGroups;
    const { messages } = this.props.message;
    const messageLoading = this.props.message.isLoading;
    const messageLoadingError = this.props.message.error;
    const divPadding = {
      paddingLeft: '20px',
      paddingTop: '20px'
    };
    const props = {
      messages: this.props.message.messages,
      onMessageClick: this.onMessageClick,
      clickedMessageId: this.state.clickedMessageId,
      authenticatedUsername: this.props.authenticatedUsername
    };

    if (messageLoading) {
      return <div style={divPadding}>Loading...</div>;
    }

    if (!messageLoading) {
      if (hasGroup && !messageLoadingError && isEmpty(messages)) {
        return (
          <div style={divPadding}>
            <p>This group currently has no messages</p>

            <div className="msg_card_bottom_padding" />
            <MessageForm />
          </div>
        );
      } else if (hasGroup && messageLoadingError) {
        return (
          <div style={divPadding}>
            <p>Unable to load messages. Please try again later</p>
          </div>
        );
      } else if (!hasGroup) {
        return <div />;
      }
    }
    return (
      <div>
        { this.state.messageOpen ?
          <MessageBody
            closeMessage={this.closeMessageBody}
            clickedMessageId={this.state.clickedMessageId}
            closeModal={this.closeModal}
            openModal={this.openModal}
            messages={this.props.message.messages}
          />
        :
          <div>
            <MessageItem {...props} />
          </div>
        }
      </div>
    );
  }
}

/**
 * Maps pieces of the redux state to props
 * @param {object} state Redux state
 * @returns {object} Username, messages and groups of
 * logged in user
 */
function mapStateToProps(state) {
  return {
    message: state.groupMessages,
    userGroups: state.userGroups,
    authenticatedUsername: state.signedInUser.user.username
  };
}

/**
 * Maps action creators to redux dispatch function
 * Action creators bound will be available as props
 * Actions generated by the action creators flows though all the reducers
 * @param {function} dispatch Redux dispatch function
 * @returns {function} Action cretaors bound to redux dispatch function
 */
function mapDispatchToProps(dispatch) {
  return bindActionCreators({
    updateReadStatus,
    getGroupMessages
  }, dispatch);
}

MessageCard.propTypes = {
  getGroupMessages: PropTypes.func.isRequired,
  updateReadStatus: PropTypes.func.isRequired,
  authenticatedUsername: PropTypes.string.isRequired,
  userGroups: PropTypes.object,
  message: PropTypes.object
};

export default connect(mapStateToProps, mapDispatchToProps)(MessageCard);
